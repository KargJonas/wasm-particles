#include <math.h>
#include <stdio.h>

#include "config.h"
#include "lib.c"

// This array contains detailed information of each particle
Particle particles[PARTICLE_COUNT];

int main(int argc, char **argv) {
  time_t current_time;
  srand((unsigned)time(&current_time));
}

void updateParticles() {
  for (int i = 0; i < PARTICLE_COUNT - 1; i++) {
// #define particle particles[i]

    float powXY, distance, force;

    particles[i].velocity.x *= FRICTION;
    particles[i].velocity.y *= FRICTION;

    for (int j = i + 1; j < PARTICLE_COUNT; j++) {
      Vector AB = {particles[j].position.x - particles[i].position.x,
                   particles[j].position.y - particles[i].position.y};

      // float powXY = pow(AB.x, 2) + pow(AB.y, 2); // This little line cost 30
      // ms and 3h to find
      powXY = AB.x * AB.x + AB.y * AB.y;
      distance = sqrt(powXY);

      // No force applied if too close
      if (distance < PARTICLE_DIAMETER || distance > MAX_DIST)
        continue;;

      // Electromagnetic force:
      // F = k * (Qa * Qb) / r ^ 2
      force = ELECTROMAG_CONST * -particles[i].charge * particles[j].charge /
                    (powXY * distance);

      // printf("%f\n", force);

      if (force > MAX_FORCE)
        force = MAX_FORCE;

      // This can be simplified
      Vector normalizedAB = {AB.x * force, AB.y * force};

      // This is a simplified implementation
      particles[i].velocity.x += normalizedAB.x;
      particles[i].velocity.y += normalizedAB.y;

      particles[j].velocity.x -= normalizedAB.x;
      particles[j].velocity.y -= normalizedAB.y;
    }
  }

  for (int i = 0; i < PARTICLE_COUNT; i++) {
    // Basic wall collision detection

    particles[i].position.x += particles[i].velocity.x;

    if (particles[i].position.x < 0 || particles[i].position.x > BOUNDS_X) {
      particles[i].position.x -= particles[i].velocity.x * 10;
      particles[i].velocity.x *= -ELASTICITY;
    }

    particles[i].position.y += particles[i].velocity.y;

    if (particles[i].position.y < 0 || particles[i].position.y > BOUNDS_Y) {
      particles[i].position.y -= particles[i].velocity.y * 10;
      particles[i].velocity.y *= -ELASTICITY;
    }
  }
}
